#<center>第11章 RTL处理及优化</center>
在all_passes链中，执行了pass_expand过程之后，GCC的中间表示就已经转换成RTL形式，此后的所有处理都是基于RTL的处理过程，即RTL_PASS。所有的RTL处理都包含在pass_rest_of_compilation的处理过程及其子过程中，主要包括了对pass_expand所生成的insn序列进行进一步的处理，包括循环优化、指令调度、寄存器分配、窥孔优化等过程，并最终根据RTL生成目标机器上的汇编代码。

##11.1 RTL处理过程
在gcc/passes.c文件中，可以通过增加调试语句，输出各种处理过程的基本信息，其中基于RTL中间表示进行的处理过程主要包括如下的Pass，其中一些主要过程给出了注释说明。

##11.2 特殊虚拟寄存器的实例化
在第10章中介绍的RTL生成过程中，表示函数参数、变量的RTX表示中均使用了一些特殊的虚拟寄存器，例如virtual_incoming_args、virtual_stack_vars、virtual_stack_dynamic以及virtual_outgoing_args等，这些虚拟寄存器是访问函数传入参数、局部变量、堆栈中动态分配空间以及传出参数的基地址，具有非常重要的意义，见表11-1。然而，最终生成代码时，这些虚拟的寄存器需要实例化成目标机器上特定的物理寄存器（硬件寄存器），这正是RTL处理过程pass_instantiate_virtual_regs的主要作用。

![](res/b11-1.png)

##11.3 指令调度
GCC中的指令调度（Instruction Scheduling）就是对当前函数中的insn序列进行重新排序，从而更充分地利用目标机器的硬件资源，提高指令执行的效率。指令调度主要考虑的因素包括数据相关（Data Dependency）、控制相关（Control Dependency）、结构相关（Structural Harzard）、指令延迟（Delay）或者指令代价（Cost）等，通常指令调度与目标机器中的流水线设置紧密相关。

###1．数据相关
###2．控制相关
###3．结构相关

####11.3.1 指令调度算法
GCC中使用的指令调度策略有多种，主要通过GCC命令的编译选项进行选择，表11-2给出了GCC中使用的指令调度编译选项及其对应的调度算法，同时也给出了这些调度算法实现的主要源代码文件。
![](res/b11-2.png)

表调度算法（List Scheduling Algorithm）是最常用的指令调度算法，也是GCC中使用的默认调度算法。表调度算法的基本思想是通过分析指令之间的相关性，包括数据相关性、控制相关性及结构相关性，建立指令之间依赖关系的有向图（Directed Acyclic Graph, DAG），计算指令的优先级（Priority），使用所有依赖性已经满足的指令构造初始化的就绪指令列表，然后重复以下两个步骤直到就绪指令列表中所有的指令被调度完毕。
（1）从就绪指令列表中按照指令的优先级取出一条指令，该指令所有的依赖关系已经满足；
（2）调度该指令，更新与该指令相关的依赖关系，将新的就绪指令插入到就绪指令列表中。

在GCC的表调度算法中，指令调度的范围通常称为一个区域（Region），指令的优先级是指从该指令执行开始，到该区域最后一条指令执行完毕所经历的指令周期数，每条指令的指令周期也称为该指令的指令代价，可使用insn_cost(insn)函数来获取。

###11.3.2 GCC指令调度的实现
基于区域的表调度算法的过程主要包括以下3个阶段的工作：
（1）函数级：主要根据函数的CFG完成区域的计算等；
（2）区域级：主要根据函数的控制流图（CFG）完成基本块之间指令调度属性的计算，还需要根据函数数据流分析的结果完成数据相关性及指令优先级的计算等；
（3）基本块级：对每个基本块中的每一条insn语句，根据其依赖关系、代价、优先级等信息进行重新排序。


###11.3.3 指令调度实例1
本节给出一个在i386 P6机器上进行指令调度的实例，i386 P6机器的流水线包括3个主要的部件：
（1）FETCH/DECODE单元，按序完成取指和译码，其中译码部件有3套，包括decoder0、decoder1和decoder2。
（2）DISPATCH/EXECUTE单元，完成乱序的指令派发和执行，其中包括了5条流水线，分别称为p0、p1、p2、p3和p4。
（3）RETIRE单元，完成指令的按序回收工作。


###11.3.4 指令调度实例2





