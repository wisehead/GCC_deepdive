#<center>从GIMPLE到RTL</center>

这里需要明确的是，在这里提到的GIMPLE到RTL的转换，确切地讲，应该是指从GIMPLE到IR-RTL的转换，即从GIMPLE转化成insn序列的过程。

##10.1 GIMPLE序列
##10.2 典型数据结构
在以函数为单位进行RTL生成时，需要对当前函数的RTL信息进行维护，这个主要由结构体struct rtl_data来描述，struct rtl_data在gcc/function.h中定义，该结构的内容众多，在此略去，其主要字段的意义在后续的RTL生成中有所涉及，可以使用如下的宏定义对其中的一些字段进行访问。

另外，在gcc/emit-rtl.c中定义了如下的宏，用来访问当前函数正在处理的insn序列。

##10.3 RTL生成的基本过程
程序代码的RTL中间表示就是双向链表所链接的insn链表，包括了insn、jump_insn、call_insn、barrier、code_label以及note六种RTX表示形式。因此，RTL的生成可以看作是以函数为单位，将该函数对应的GIMPLE序列转换成相应的insn序列的过程

作为GIMPLE处理中的最后关键过程（Pass）, struct rtl_opt_pass pass_expand完成了GIMPLE到RTL的转换，具体来说，该Pass的声明如下，其处理的入口函数为gcc/cfgexpand.c中的gimple_expand_cfg函数。

执行该Pass时，函数调用堆栈通常如下所示：

```cpp
            (gdb) bt
            #0  gimple_expand_cfg () at ../.././gcc/cfgexpand.c:2288
            #1  0x082933f8 in execute_one_pass (pass=0x898de60) at ../.././gcc/passes.c:1277
            #2  0x082935f8 in execute_pass_list (pass=0x898de60) at ../.././gcc/passes.c:1326
            #3  0x083a70dc in tree_rest_of_compilation (fndecl=0xb7c82900)
                at ../.././gcc/tree-optimize.c:420
            #4  0x0851048fin cgraph_expand_function (node=0xb7c82980)
                at ../.././gcc/cgraphunit.c:1047
            #5  0x085108a0 in cgraph_output_in_order () at ../.././gcc/cgraphunit.c:1195
            #6  0x08510b9b in cgraph_optimize () at ../.././gcc/cgraphunit.c:1306
            #7  0x0805ecdc in c_write_global_declarations () at ../.././gcc/c-decl.c:8102
            #8  0x083586a5 in compile_file () at ../.././gcc/toplev.c:981
            #9  0x0835a1afin do_compile () at ../.././gcc/toplev.c:2193
            #10 0x0835a211 in toplev_main (argc=2, argv=0xbfc6c494) at ../.././gcc/toplev.c:2225
            #11 0x080c41de in main (argc=Cannot access memory at address 0x4cc)
                at ../.././gcc/main.c:35
```

从该函数的主要内容可以看出，每个函数代码从GIMPLE形式转换到RTL的过程主要包括如下几个步骤：
（1）变量展开：调用expand_used_vars(void)函数，对当前函数中所有的变量进行分析，在虚拟寄存器或者堆栈中为其分配空间，并生成对应的RTX。
（2）参数和返回值的处理：调用expand_function_start(current_function_decl)函数，对函数的参数和返回值进行处理，生成其对应的RTX。
（3）初始块的处理：调用construct_init_block(void)函数，创建初始块，并修正函数的控制流图CFG。
（4）基本块的展开：对函数体中每个基本块所包含的GIMPLE语句序列逐个进行展开，这是RTL生成的主要部分，采用的形式为：[插图]即对函数初始块之后的每个基本块逐一进行展开。
（5）退出块的处理：调用construct_exit_block(void)函数，创建退出块，生成函数退出时的RTL，并修正函数的控制流图CFG。
（6）其他处理。从下一节开始，将对GIMPLE到RTL的转换过程进行仔细的分析，并通过大量的实例说明GIMPLE的展开过程。

###10.3.1 变量展开

