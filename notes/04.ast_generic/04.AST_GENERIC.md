如图4-1所示，GCC在将高级程序源代码转换成目标机器汇编代码的过程中，主要使用了三种中间表示形式，即抽象语法树（Abstract Syntax Tree, AST）、GIMPLE及寄存器传输语言（Register Transfer Language, RTL）。本书就紧紧围绕这三种中间表示的基本概念、表示方法、存储结构及其生成技术等展开。

![](res/4-1.png)

##4.1 抽象语法树
抽象语法树是编译系统中最常见的一种树形的中间表示形式，用来对前端语言的源代码进行规范的抽象表示。不同的高级程序设计语言通过其相应的词法/语法分析过程，会得到不同形式的抽象语法树，这些抽象语法树与编程语言的特征紧密相关，一般都包含了部分语言相关的AST节点表示。
![](res/4-2.png)

GENERIC是指规范的AST。一般来说，如果一种前端语言的AST均可以使用gcc/tree. h中所表示的树节点表示，那么该AST就是规范的AST，即GENERIC形式。可以看出，GENERIC是一种规范的AST表示，引入GENERIC的目的就是力求寻找一种与前端语言无关的AST统一表示，便于对各种语言的AST进行一种通用的处理而已。

图4-3中给出了GCC中描述C语言语句“b=a++; ”的AST结构及其主要节点信息。
![](res/4-3.png)

##4.2 树节点的声明

（1）标识（TREE_CODE）:DEFTREECODE宏定义中的SYM参数，描述了该节点代表的是一个什么样的节点，可以看作该树节点的语义描述。

> DEFTREECODE (PLUS_EXPR, "plus_expr", tcc_binary, 2)

该树节点的TREE_CODE为PLUS_EXPR，用来表示一个加法操作语义的树节点；

（2）名称（NAME）:DEFTREECODE宏定义中的NAME参数，表示该树节点的名称，使用字符串来描述，主要用来进行AST中间结果的显示，方便用户直观地了解该树节点的信息。

（3）类型（TREE_CODE CLASS, TCC）:DEFTREECODE宏定义中的TYPE参数，描述了该树节点的TREE_CODE所属的类型。例如，对于代表加法、减法和乘法运算的树节点，其分别声明如下：

> /* Simple arithmetic.  */
> DEFTREECODE (PLUS_EXPR, "plus_expr", tcc_binary, 2)
> DEFTREECODE (MINUS_EXPR, "minus_expr", tcc_binary, 2)
> DEFTREECODE (MULT_EXPR, "mult_expr", tcc_binary, 2)

而从语义类型上来说，这些运算树节点都属于同一个类型，即双目运算(tcc_binary)。

（4）长度：DEFTREECODE宏定义中的LEN参数，用来描述该树节点所包含的操作数的数目。


####关于类型的名称也在gcc/tree.c中给出了相关的定义。
```cpp
/* Tree code classes.  */

/* Each tree_code has an associated code class represented by a
   TREE_CODE_CLASS.  */

enum tree_code_class {
  tcc_exceptional, /* An exceptional code (fits no category).  */
  tcc_constant,    /* A constant.  */
  /* Order of tcc_type and tcc_declaration is important.  */
  tcc_type,        /* A type object code.  */
  tcc_declaration, /* A declaration (also serving as variable refs).  */
  tcc_reference,   /* A reference to storage.  */
  tcc_comparison,  /* A comparison expression.  */
  tcc_unary,       /* A unary arithmetic expression.  */
  tcc_binary,      /* A binary arithmetic expression.  */
  tcc_statement,   /* A statement expression, which have side effects
              but usually no interesting value.  */
  tcc_vl_exp,      /* A function call or other expression with a
              variable-length operand vector.  */
  tcc_expression   /* Any other expression.  */
};
```

通过上面的介绍可以看出，GCC中对一个树节点的声明主要包括4个方面，即标识、名称、类型及操作数个数等，并采用专门的数据结构进行相关内容的存储，如表4-1所示。
![](res/b4-1.png)

##4.3 树节点结构
所有树节点的存储都使用union类型，即联合体。在gcc/tree.h中定义的union tree_node的联合体如下：

```cpp
/* Define the overall contents of a tree node.
   It may be any of the structures declared above
   for various types of node.  */

union tree_node GTY ((ptr_alias (union lang_tree_node),
              desc ("tree_node_structure (&%h)")))
{
  struct tree_base GTY ((tag ("TS_BASE"))) base;
  struct tree_common GTY ((tag ("TS_COMMON"))) common;
  struct tree_int_cst GTY ((tag ("TS_INT_CST"))) int_cst;
  struct tree_real_cst GTY ((tag ("TS_REAL_CST"))) real_cst;
  struct tree_fixed_cst GTY ((tag ("TS_FIXED_CST"))) fixed_cst;
  struct tree_vector GTY ((tag ("TS_VECTOR"))) vector;
  struct tree_string GTY ((tag ("TS_STRING"))) string;
  struct tree_complex GTY ((tag ("TS_COMPLEX"))) complex;
  struct tree_identifier GTY ((tag ("TS_IDENTIFIER"))) identifier;
  struct tree_decl_minimal GTY((tag ("TS_DECL_MINIMAL"))) decl_minimal;
  struct tree_decl_common GTY ((tag ("TS_DECL_COMMON"))) decl_common;
  struct tree_decl_with_rtl GTY ((tag ("TS_DECL_WRTL"))) decl_with_rtl;
  struct tree_decl_non_common  GTY ((tag ("TS_DECL_NON_COMMON"))) decl_non_common;
  struct tree_parm_decl  GTY  ((tag ("TS_PARM_DECL"))) parm_decl;
  struct tree_decl_with_vis GTY ((tag ("TS_DECL_WITH_VIS"))) decl_with_vis;
  struct tree_var_decl GTY ((tag ("TS_VAR_DECL"))) var_decl;
  struct tree_field_decl GTY ((tag ("TS_FIELD_DECL"))) field_decl;
  struct tree_label_decl GTY ((tag ("TS_LABEL_DECL"))) label_decl;
  struct tree_result_decl GTY ((tag ("TS_RESULT_DECL"))) result_decl;
  struct tree_const_decl GTY ((tag ("TS_CONST_DECL"))) const_decl;
  struct tree_type_decl GTY ((tag ("TS_TYPE_DECL"))) type_decl;
  struct tree_function_decl GTY ((tag ("TS_FUNCTION_DECL"))) function_decl;
  struct tree_type GTY ((tag ("TS_TYPE"))) type;
  struct tree_list GTY ((tag ("TS_LIST"))) list;
  struct tree_vec GTY ((tag ("TS_VEC"))) vec; 
  struct tree_exp GTY ((tag ("TS_EXP"))) exp; 
  struct tree_ssa_name GTY ((tag ("TS_SSA_NAME"))) ssa_name;
  struct tree_block GTY ((tag ("TS_BLOCK"))) block;
  struct tree_binfo GTY ((tag ("TS_BINFO"))) binfo;
  struct tree_statement_list GTY ((tag ("TS_STATEMENT_LIST"))) stmt_list;
  struct tree_constructor GTY ((tag ("TS_CONSTRUCTOR"))) constructor;
  struct tree_memory_tag GTY ((tag ("TS_MEMORY_TAG"))) mtag;
  struct tree_omp_clause GTY ((tag ("TS_OMP_CLAUSE"))) omp_clause;
  struct tree_memory_partition_tag GTY ((tag ("TS_MEMORY_PARTITION_TAG"))) mpt; 
  struct tree_optimization_option GTY ((tag ("TS_OPTIMIZATION"))) optimization;
  struct tree_target_option GTY ((tag ("TS_TARGET_OPTION"))) target_option;
};
```

表4-2给出了这些不同的结构体所存储树节点的基本描述，union tree_node就是这些所有的存储结构体的一个泛称。
![](res/b4-2.png)

###4.3.3 常量节点

```cpp
             struct tree_int_cst
             {
               struct tree_common common;
               double_int int_cst;
             };

             typedef struct
             {
               unsigned HOST_WIDE_INT low;
               HOST_WIDE_INT high;
             } double_int;
```
struct tree_int_cst与struct tree_common及struct tree_base之间的“继承关系”如图4-5所示。也就是说，structtree_int_cst结构体中包含了一个struct tree_common结构体成员变量，而struct tree_common结构体中则包含了一个struct tree_base结构体成员变量。其他的常量树节点也具有类似的特性。

![](res/4-5.png)

###4.3.5 声明节点
在GCC中，表示声明的树节点类型很多，例如变量声明节点、函数声明节点、参数声明节点、返回值声明节点等。同样，用来存储这些声明节点的结构体也有多种，可以使用下述命令查看：

```
             [GCC@localhost gcc-4.4.0]$  grep ^DEFTREESTRUCT gcc/treestruct.def  | grep _DECL
             DEFTREESTRUCT(TS_DECL_MINIMAL, "decl minimal")
             DEFTREESTRUCT(TS_DECL_COMMON, "decl common")
             DEFTREESTRUCT(TS_DECL_WRTL, "decl with RTL")
             DEFTREESTRUCT(TS_DECL_NON_COMMON, "decl non-common")
             DEFTREESTRUCT(TS_DECL_WITH_VIS, "decl with visibility")
             DEFTREESTRUCT(TS_FIELD_DECL, "field decl")
             DEFTREESTRUCT(TS_VAR_DECL, "var decl")
             DEFTREESTRUCT(TS_PARM_DECL, "parm decl")
             DEFTREESTRUCT(TS_LABEL_DECL, "label decl")
             DEFTREESTRUCT(TS_RESULT_DECL, "result decl")
             DEFTREESTRUCT(TS_CONST_DECL, "const decl")
             DEFTREESTRUCT(TS_TYPE_DECL, "label decl")
             DEFTREESTRUCT(TS_FUNCTION_DECL, "function decl")
```
以上这13种与声明有关的存储结构之间并不是完全独立的，而是具有一定的“继承”关系，图4-6给出了这些声明节点存储结构之间的关系。在该图中，如果存在A→B的关系，那么在A结构体中就包含了一个类型为B的结构体成员变量。例如struct tree_decl_common中就包含了一个成员变量struct tree_decl_minimal。
![](res/4-6.png)

从图4-6可以看出，struct tree_decl_minimal及struct tree_decl_common是所有表示声明的结构体的基础，其他所有表示声明的结构体中都包含了该结构体成员。各种不同的声明结构体用来描述不同的声明，例如，变量声明使用struct tree_var_decl结构体存储，函数声明则使用struct tree_function_decl结构体存储。表4-3给出了常见的声明节点及其TREE_CODE、存储结构的对应关系。
![](res/b4-3.png)

##4.4 AST输出及图示
###4.4.1 
GCC提供了-fdump-tree-original、-fdump-tree-all等选项，可以输出GCC处理源代码过程中的AST及GIMPLE中间表示信息。例如使用-fudmp-tree-original就可以输出GCC进行词法/语法解析后所生成的AST信息，然而该AST信息过于繁杂，不便分析，因此，本节通过在GCC源代码中增加一些调试语句，从而输出AST信息。

在gcc/gimplify.c的gimplify_function_tree函数中添加如下语句，主要调用dump_node函数打印当前函数的AST节点，此时打印的节点信息是在AST转换为GIMPLE之前的内容。

```cpp
/* Entry point to the gimplification pass.  FNDECL is the FUNCTION_DECL
   node for the function we want to gimplify.

   Returns the sequence of GIMPLE statements corresponding to the body
   of FNDECL.  */

void
gimplify_function_tree (tree fndecl)
{
  tree oldfn, parm, ret;
  gimple_seq seq;
  gimple bind;

  //B_chenhui
  FILE *fp;
  char filename[128];
  sprintf(filename, "AST-%s", current_function_name());
  fp = fopen(filename, "w");
  //dump_node(fndecl, 0x1FFF8, fp);
  //0x1FFF8不会打印addr，改成0x1FFF9
  dump_node(fndecl, 0x1FFF9, fp);
  fclose(fp);
  //E_chenhui
  oldfn = current_function_decl;
  current_function_decl = fndecl;
  ...
  ...
}
```

编译该GCC源代码，并使用编译出来的cc1来编译下面例子中的源代码，从而生成其中各个函数对应的AST信息，例如函数func对应的AST信息文件名称为AST-func, main函数对应的AST信息文件名称为AST-main等。

###4.4.2
假设有如下的源代码：

```cpp
int main(int argc, char *argv[])
{
    int i = 0;
    int sum = 0;
    for (i = 0;  i < 10; i++)
    {
        sum = sum + i;
    }
    return sum;
}
```

编译该源代码：
>   cc1 test.c
 
 该源代码中函数main对应的AST文件名称为AST-main，查看该文件。(有点失败，没有生成address相关的信息，后面看看怎么生成？)
 
 ```
 @1      function_decl    name: @2       type: @3       srcp: test.c:1
                         args: @4       link: extern   body: @5
@2      identifier_node  strg: main     lngt: 4
@3      function_type    size: @6       algn: 8        retn: @7
                         prms: @8
@4      parm_decl        name: @9       type: @7       scpe: @1
                         srcp: test.c:1                chan: @10
                         argt: @7       size: @11      algn: 32
                         used: 0
@5      bind_expr        type: @12      vars: @13      body: @14
@6      integer_cst      type: @15      low : 8
@7      integer_type     name: @16      size: @11      algn: 32
                         prec: 32       sign: signed   min : @17
                         max : @18
@8      tree_list        valu: @7       chan: @19
@9      identifier_node  strg: argc     lngt: 4
@10     parm_decl        name: @20      type: @21      scpe: @1
                         srcp: test.c:1                argt: @21
                         size: @22      algn: 64       used: 0
@11     integer_cst      type: @15      low : 32
@12     void_type        name: @23      algn: 8
@13     var_decl         name: @24      type: @7       scpe: @1
                         srcp: test.c:3                chan: @25
                         init: @26      size: @11      algn: 32
                         used: 1
@14     statement_list   0   : @27      1   : @28      2   : @29
                         3   : @30      4   : @31      5   : @32
                         6   : @33      7   : @34      8   : @35
                         9   : @36      10  : @37
@15     integer_type     name: @38      size: @22      algn: 64
                         prec: 64       sign: unsigned min : @39
                         max : @40
@16     type_decl        name: @41      type: @7       srcp: <built-in>:0
@17     integer_cst      type: @7       high: -1       low : -2147483648
@18     integer_cst      type: @7       low : 2147483647
@19     tree_list        valu: @21      chan: @42
@20     identifier_node  strg: argv     lngt: 4
@21     pointer_type     size: @22      algn: 64       ptd : @43
@22     integer_cst      type: @15      low : 64
@23     type_decl        name: @44      type: @12      srcp: <built-in>:0
@24     identifier_node  strg: i        lngt: 1
@25     var_decl         name: @45      type: @7       scpe: @1
                         srcp: test.c:4                init: @26
                         size: @11      algn: 32       used: 1
@26     integer_cst      type: @7       low : 0
@27     decl_expr        type: @12
@28     decl_expr        type: @12
 ```
 
###4.4.3
```bash
(gdb) bt
#0  dump_node (t=0x7ffff1b2b000, flags=131064, stream=0xf89ba0) at ../.././gcc/tree-dump.c:740
#1  0x000000000056176d in gimplify_function_tree (fndecl=0x7ffff1b2b000) at ../.././gcc/gimplify.c:7465
#2  0x000000000045d738 in c_genericize (fndecl=0x7ffff1b2b000) at ../.././gcc/c-gimplify.c:107
#3  0x000000000040ed70 in finish_function () at ../.././gcc/c-decl.c:6823
#4  0x0000000000459d12 in c_parser_declaration_or_fndef (parser=0x7ffff7b5a140, fndef_ok=<value optimized out>, empty_ok=<value optimized out>, nested=0 '\000',
    start_attr_ok=<value optimized out>) at ../.././gcc/c-parser.c:1319
#5  0x000000000045c698 in c_parser_translation_unit () at ../.././gcc/c-parser.c:979
#6  c_parse_file () at ../.././gcc/c-parser.c:8314
#7  0x0000000000445375 in c_common_parse_file (set_yydebug=<value optimized out>) at ../.././gcc/c-opts.c:1252
#8  0x000000000064e254 in compile_file (argc=<value optimized out>, argv=<value optimized out>) at ../.././gcc/toplev.c:970
#9  do_compile (argc=<value optimized out>, argv=<value optimized out>) at ../.././gcc/toplev.c:2197
#10 toplev_main (argc=<value optimized out>, argv=<value optimized out>) at ../.././gcc/toplev.c:2229
#11 0x000000318ae1ecdd in __libc_start_main () from /lib64/libc.so.6
#12 0x00000000004043d9 in _start ()
```