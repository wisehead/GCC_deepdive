如图4-1所示，GCC在将高级程序源代码转换成目标机器汇编代码的过程中，主要使用了三种中间表示形式，即抽象语法树（Abstract Syntax Tree, AST）、GIMPLE及寄存器传输语言（Register Transfer Language, RTL）。本书就紧紧围绕这三种中间表示的基本概念、表示方法、存储结构及其生成技术等展开。

![](res/4-1.png)

##4.1 抽象语法树
抽象语法树是编译系统中最常见的一种树形的中间表示形式，用来对前端语言的源代码进行规范的抽象表示。不同的高级程序设计语言通过其相应的词法/语法分析过程，会得到不同形式的抽象语法树，这些抽象语法树与编程语言的特征紧密相关，一般都包含了部分语言相关的AST节点表示。
![](res/4-2.png)

GENERIC是指规范的AST。一般来说，如果一种前端语言的AST均可以使用gcc/tree. h中所表示的树节点表示，那么该AST就是规范的AST，即GENERIC形式。可以看出，GENERIC是一种规范的AST表示，引入GENERIC的目的就是力求寻找一种与前端语言无关的AST统一表示，便于对各种语言的AST进行一种通用的处理而已。

图4-3中给出了GCC中描述C语言语句“b=a++; ”的AST结构及其主要节点信息。
![](res/4-3.png)

##4.2 树节点的声明

（1）标识（TREE_CODE）:DEFTREECODE宏定义中的SYM参数，描述了该节点代表的是一个什么样的节点，可以看作该树节点的语义描述。

> DEFTREECODE (PLUS_EXPR, "plus_expr", tcc_binary, 2)

该树节点的TREE_CODE为PLUS_EXPR，用来表示一个加法操作语义的树节点；

（2）名称（NAME）:DEFTREECODE宏定义中的NAME参数，表示该树节点的名称，使用字符串来描述，主要用来进行AST中间结果的显示，方便用户直观地了解该树节点的信息。

（3）类型（TREE_CODE CLASS, TCC）:DEFTREECODE宏定义中的TYPE参数，描述了该树节点的TREE_CODE所属的类型。例如，对于代表加法、减法和乘法运算的树节点，其分别声明如下：

> /* Simple arithmetic.  */
> DEFTREECODE (PLUS_EXPR, "plus_expr", tcc_binary, 2)
> DEFTREECODE (MINUS_EXPR, "minus_expr", tcc_binary, 2)
> DEFTREECODE (MULT_EXPR, "mult_expr", tcc_binary, 2)

而从语义类型上来说，这些运算树节点都属于同一个类型，即双目运算(tcc_binary)。

（4）长度：DEFTREECODE宏定义中的LEN参数，用来描述该树节点所包含的操作数的数目。


####关于类型的名称也在gcc/tree.c中给出了相关的定义。
```cpp
/* Tree code classes.  */

/* Each tree_code has an associated code class represented by a
   TREE_CODE_CLASS.  */

enum tree_code_class {
  tcc_exceptional, /* An exceptional code (fits no category).  */
  tcc_constant,    /* A constant.  */
  /* Order of tcc_type and tcc_declaration is important.  */
  tcc_type,        /* A type object code.  */
  tcc_declaration, /* A declaration (also serving as variable refs).  */
  tcc_reference,   /* A reference to storage.  */
  tcc_comparison,  /* A comparison expression.  */
  tcc_unary,       /* A unary arithmetic expression.  */
  tcc_binary,      /* A binary arithmetic expression.  */
  tcc_statement,   /* A statement expression, which have side effects
              but usually no interesting value.  */
  tcc_vl_exp,      /* A function call or other expression with a
              variable-length operand vector.  */
  tcc_expression   /* Any other expression.  */
};
```

通过上面的介绍可以看出，GCC中对一个树节点的声明主要包括4个方面，即标识、名称、类型及操作数个数等，并采用专门的数据结构进行相关内容的存储，如表4-1所示。
![](res/b4-1.png)

##4.3 树节点结构
所有树节点的存储都使用union类型，即联合体。在gcc/tree.h中定义的union tree_node的联合体如下：

```cpp
/* Define the overall contents of a tree node.
   It may be any of the structures declared above
   for various types of node.  */

union tree_node GTY ((ptr_alias (union lang_tree_node),
              desc ("tree_node_structure (&%h)")))
{
  struct tree_base GTY ((tag ("TS_BASE"))) base;
  struct tree_common GTY ((tag ("TS_COMMON"))) common;
  struct tree_int_cst GTY ((tag ("TS_INT_CST"))) int_cst;
  struct tree_real_cst GTY ((tag ("TS_REAL_CST"))) real_cst;
  struct tree_fixed_cst GTY ((tag ("TS_FIXED_CST"))) fixed_cst;
  struct tree_vector GTY ((tag ("TS_VECTOR"))) vector;
  struct tree_string GTY ((tag ("TS_STRING"))) string;
  struct tree_complex GTY ((tag ("TS_COMPLEX"))) complex;
  struct tree_identifier GTY ((tag ("TS_IDENTIFIER"))) identifier;
  struct tree_decl_minimal GTY((tag ("TS_DECL_MINIMAL"))) decl_minimal;
  struct tree_decl_common GTY ((tag ("TS_DECL_COMMON"))) decl_common;
  struct tree_decl_with_rtl GTY ((tag ("TS_DECL_WRTL"))) decl_with_rtl;
  struct tree_decl_non_common  GTY ((tag ("TS_DECL_NON_COMMON"))) decl_non_common;
  struct tree_parm_decl  GTY  ((tag ("TS_PARM_DECL"))) parm_decl;
  struct tree_decl_with_vis GTY ((tag ("TS_DECL_WITH_VIS"))) decl_with_vis;
  struct tree_var_decl GTY ((tag ("TS_VAR_DECL"))) var_decl;
  struct tree_field_decl GTY ((tag ("TS_FIELD_DECL"))) field_decl;
  struct tree_label_decl GTY ((tag ("TS_LABEL_DECL"))) label_decl;
  struct tree_result_decl GTY ((tag ("TS_RESULT_DECL"))) result_decl;
  struct tree_const_decl GTY ((tag ("TS_CONST_DECL"))) const_decl;
  struct tree_type_decl GTY ((tag ("TS_TYPE_DECL"))) type_decl;
  struct tree_function_decl GTY ((tag ("TS_FUNCTION_DECL"))) function_decl;
  struct tree_type GTY ((tag ("TS_TYPE"))) type;
  struct tree_list GTY ((tag ("TS_LIST"))) list;
  struct tree_vec GTY ((tag ("TS_VEC"))) vec; 
  struct tree_exp GTY ((tag ("TS_EXP"))) exp; 
  struct tree_ssa_name GTY ((tag ("TS_SSA_NAME"))) ssa_name;
  struct tree_block GTY ((tag ("TS_BLOCK"))) block;
  struct tree_binfo GTY ((tag ("TS_BINFO"))) binfo;
  struct tree_statement_list GTY ((tag ("TS_STATEMENT_LIST"))) stmt_list;
  struct tree_constructor GTY ((tag ("TS_CONSTRUCTOR"))) constructor;
  struct tree_memory_tag GTY ((tag ("TS_MEMORY_TAG"))) mtag;
  struct tree_omp_clause GTY ((tag ("TS_OMP_CLAUSE"))) omp_clause;
  struct tree_memory_partition_tag GTY ((tag ("TS_MEMORY_PARTITION_TAG"))) mpt; 
  struct tree_optimization_option GTY ((tag ("TS_OPTIMIZATION"))) optimization;
  struct tree_target_option GTY ((tag ("TS_TARGET_OPTION"))) target_option;
};
```

表4-2给出了这些不同的结构体所存储树节点的基本描述，union tree_node就是这些所有的存储结构体的一个泛称。
![](res/b4-2.png)

###4.3.3 常量节点

```cpp
             struct tree_int_cst
             {
               struct tree_common common;
               double_int int_cst;
             };

             typedef struct
             {
               unsigned HOST_WIDE_INT low;
               HOST_WIDE_INT high;
             } double_int;
```
struct tree_int_cst与struct tree_common及struct tree_base之间的“继承关系”如图4-5所示。也就是说，structtree_int_cst结构体中包含了一个struct tree_common结构体成员变量，而struct tree_common结构体中则包含了一个struct tree_base结构体成员变量。其他的常量树节点也具有类似的特性。

![](res/4-5.png)

###4.3.5 声明节点
在GCC中，表示声明的树节点类型很多，例如变量声明节点、函数声明节点、参数声明节点、返回值声明节点等。同样，用来存储这些声明节点的结构体也有多种，可以使用下述命令查看：

```
             [GCC@localhost gcc-4.4.0]$  grep ^DEFTREESTRUCT gcc/treestruct.def  | grep _DECL
             DEFTREESTRUCT(TS_DECL_MINIMAL, "decl minimal")
             DEFTREESTRUCT(TS_DECL_COMMON, "decl common")
             DEFTREESTRUCT(TS_DECL_WRTL, "decl with RTL")
             DEFTREESTRUCT(TS_DECL_NON_COMMON, "decl non-common")
             DEFTREESTRUCT(TS_DECL_WITH_VIS, "decl with visibility")
             DEFTREESTRUCT(TS_FIELD_DECL, "field decl")
             DEFTREESTRUCT(TS_VAR_DECL, "var decl")
             DEFTREESTRUCT(TS_PARM_DECL, "parm decl")
             DEFTREESTRUCT(TS_LABEL_DECL, "label decl")
             DEFTREESTRUCT(TS_RESULT_DECL, "result decl")
             DEFTREESTRUCT(TS_CONST_DECL, "const decl")
             DEFTREESTRUCT(TS_TYPE_DECL, "label decl")
             DEFTREESTRUCT(TS_FUNCTION_DECL, "function decl")
```
以上这13种与声明有关的存储结构之间并不是完全独立的，而是具有一定的“继承”关系，图4-6给出了这些声明节点存储结构之间的关系。在该图中，如果存在A→B的关系，那么在A结构体中就包含了一个类型为B的结构体成员变量。例如struct tree_decl_common中就包含了一个成员变量struct tree_decl_minimal。
![](res/4-6.png)

从图4-6可以看出，struct tree_decl_minimal及struct tree_decl_common是所有表示声明的结构体的基础，其他所有表示声明的结构体中都包含了该结构体成员。各种不同的声明结构体用来描述不同的声明，例如，变量声明使用struct tree_var_decl结构体存储，函数声明则使用struct tree_function_decl结构体存储。表4-3给出了常见的声明节点及其TREE_CODE、存储结构的对应关系。
![](res/b4-3.png)

###4.3.7 struct tree_decl_common
在struct tree_decl_minimal中，描述了声明的基本信息：locus = 78, uid = 1230, name =0xb7d66930，分别表示该声明在源文件中的位置locus、该声明的uid，以及该声明对应的字符串名称。可以通过gdb获取该声明所在源代码的文件名称及其行号：

```
(gdb) print (expand_location (78)).file          /*打印文件名称*/
$15 = 0xbffff544 "test_cst.c"
(gdb) print (expand_location (78)).line          /*打印行号*/
$16 = 1
```
###4.3.8 struct tree_field_decl
该结构体常用来存储用户定义的结构体成员变量的声明，其定义如下：

```
 struct tree_field_decl
 {
   struct tree_decl_common common;
   tree offset;                      /*字段偏移量*/
   tree bit_field_type;              /*字段类型*/
   tree qualifier;                   /*字段修饰符*/
   tree bit_offset;                  /*字段的位偏移量*/
   tree fcontext;                    /*字段所在的结构体或联合体节点*/
 };
```
下面使用一个例子来说明。例4-9 struct tree_field_decl实例分析

```c
int field(){
struct student{
  char gender;
  short age;
  char name[20];
}tom;

  tom.gender = 'F';
  tom.age = 18;
  strcpy(tom.name, "TOM");
  return 0;
}
```

综上，三个成员变量节点的主要信息如表4-4所示。
![](res/b4-4.png)

另外，也可以将gender声明节点的关键信息转换成如图4-7所示的关系图，其中size字段就是表4-4中的成员大小（位数）, bpos即表4-4中存储偏移量（位数），均由一个整数常量节点来表示，name字段指向该声明的标识符节点，type指向该成员变量的类型节点，chan字段指向下一个成员变量声明节点，scpe字段指向该成员变量所在的结构体类型节点。可以看出在struct student中，gender成员变量的位数为8位，而存储的偏移量为0位，该字段的名称为“gender”。
![](res/4-7.png)
##4.4 AST输出及图示
###4.4.1 
GCC提供了-fdump-tree-original、-fdump-tree-all等选项，可以输出GCC处理源代码过程中的AST及GIMPLE中间表示信息。例如使用-fudmp-tree-original就可以输出GCC进行词法/语法解析后所生成的AST信息，然而该AST信息过于繁杂，不便分析，因此，本节通过在GCC源代码中增加一些调试语句，从而输出AST信息。

在gcc/gimplify.c的gimplify_function_tree函数中添加如下语句，主要调用dump_node函数打印当前函数的AST节点，此时打印的节点信息是在AST转换为GIMPLE之前的内容。

```cpp
/* Entry point to the gimplification pass.  FNDECL is the FUNCTION_DECL
   node for the function we want to gimplify.

   Returns the sequence of GIMPLE statements corresponding to the body
   of FNDECL.  */

void
gimplify_function_tree (tree fndecl)
{
  tree oldfn, parm, ret;
  gimple_seq seq;
  gimple bind;

  //B_chenhui
  FILE *fp;
  char filename[128];
  sprintf(filename, "AST-%s", current_function_name());
  fp = fopen(filename, "w");
  //dump_node(fndecl, 0x1FFF8, fp);
  //0x1FFF8不会打印addr，改成0x1FFF9
  dump_node(fndecl, 0x1FFF9, fp);
  fclose(fp);
  //E_chenhui
  oldfn = current_function_decl;
  current_function_decl = fndecl;
  ...
  ...
}
```

编译该GCC源代码，并使用编译出来的cc1来编译下面例子中的源代码，从而生成其中各个函数对应的AST信息，例如函数func对应的AST信息文件名称为AST-func, main函数对应的AST信息文件名称为AST-main等。

###4.4.2
假设有如下的源代码：

```cpp
int main(int argc, char *argv[])
{
    int i = 0;
    int sum = 0;
    for (i = 0;  i < 10; i++)
    {
        sum = sum + i;
    }
    return sum;
}
```

编译该源代码：
>   cc1 test.c
 
 该源代码中函数main对应的AST文件名称为AST-main，查看该文件。(有点失败，没有生成address相关的信息，后面看看怎么生成？)
 
 ```
@1      function_decl    name: @2       type: @3       srcp: test.c:1      
                         args: @4       link: extern   body: @5      
                         addr: 7fe466baec00 
@2      identifier_node  strg: main     lngt: 4        addr: 7fe466ba8ae0 
@3      function_type    size: @6       algn: 8        retn: @7      
                         prms: @8       addr: 7fe466baf540 
@4      parm_decl        name: @9       type: @7       scpe: @1      
                         srcp: test.c:1                chan: @10     
                         argt: @7       size: @11      algn: 32      
                         used: 0        addr: 7fe466c96480 
@5      bind_expr        type: @12      vars: @13      body: @14     
                         addr: 7fe466c95730 
@6      integer_cst      type: @15      low : 8        addr: 7fe466c8d7b0 
@7      integer_type     name: @16      size: @11      algn: 32      
                         prec: 32       sign: signed   min : @17     
                         max : @18      addr: 7fe466c9d540 
@8      tree_list        valu: @7       chan: @19      addr: 7fe466bc32a0 
@9      identifier_node  strg: argc     lngt: 4        addr: 7fe466bb5f60 
@10     parm_decl        name: @20      type: @21      scpe: @1      
                         srcp: test.c:1                argt: @21     
                         size: @22      algn: 64       used: 0       
                         addr: 7fe466c96510 
@11     integer_cst      type: @15      low : 32       addr: 7fe466c8da50 
@12     void_type        name: @23      algn: 8        addr: 7fe466cac3c0 
@13     var_decl         name: @24      type: @7       scpe: @1      
                         srcp: test.c:3                chan: @25     
                         init: @26      size: @11      algn: 32      
                         used: 1        addr: 7fe466d636e0 
@14     statement_list   0   : @27      1   : @28      2   : @29     
                         3   : @30      4   : @31      5   : @32     
                         6   : @33      7   : @34      8   : @35     
                         9   : @36      10  : @37      addr: 7fe466bc3360 
@15     integer_type     name: @38      size: @22      algn: 64      
                         prec: 64       sign: unsigned min : @39     
                         max : @40      addr: 7fe466c9d0c0 
@16     type_decl        name: @41      type: @7       srcp: <built-in>:0      
                         addr: 7fe466c9dc00 
@17     integer_cst      type: @7       high: -1       low : -2147483648 
                         addr: 7fe466c8d9c0 
@18     integer_cst      type: @7       low : 2147483647  addr: 7fe466c8d9f0 
@19     tree_list        valu: @21      chan: @42      addr: 7fe466bc3270 
@20     identifier_node  strg: argv     lngt: 4        addr: 7fe466bc4000 
@21     pointer_type     size: @22      algn: 64       ptd : @43     
                         addr: 7fe466baf480 
@22     integer_cst      type: @15      low : 64       addr: 7fe466c8db40 
@23     type_decl        name: @44      type: @12      srcp: <built-in>:0      
                         addr: 7fe466cb5000 
@24     identifier_node  strg: i        lngt: 1        addr: 7fe466bc4060 
@25     var_decl         name: @45      type: @7       scpe: @1      
                         srcp: test.c:4                init: @26     
                         size: @11      algn: 32       used: 1       
                         addr: 7fe466d63780 
@26     integer_cst      type: @7       low : 0        addr: 7fe466caa4e0 
@27     decl_expr        type: @12      addr: 7fe46cc511c0 
@28     decl_expr        type: @12      addr: 7fe46cc51200 
@29     modify_expr      type: @7       op 0: @13      op 1: @26     
                         addr: 7fe46cc51240 
@30     goto_expr        type: @12      labl: @46      addr: 7fe46cc51440 
@31     label_expr       type: @12      name: @47      addr: 7fe46cc51380 
@32     modify_expr      type: @7       op 0: @25      op 1: @48     
                         addr: 7fe46cc51340 
@33     postincrement_expr type: @7       op 0: @13      op 1: @49     
                         addr: 7fe46cc512c0 
@34     label_expr       type: @12      name: @46      addr: 7fe46cc51400 
@35     cond_expr        type: @12      op 0: @50      op 1: @51     
                         op 2: @52      addr: 7fe466c956e0 
@36     label_expr       type: @12      name: @53      addr: 7fe46cc514c0 
@37     return_expr      type: @12      expr: @54      addr: 7fe46cc51540 
@38     identifier_node  strg: bit_size_type           lngt: 13      
                         addr: 7fe466c9cd80 
@39     integer_cst      type: @15      low : 0        addr: 7fe466caa390 
@40     integer_cst      type: @15      low : -1       addr: 7fe466caa330 
@41     identifier_node  strg: int      lngt: 3        addr: 7fe466c9c1e0 
@42     tree_list        valu: @12      addr: 7fe466caa9c0 
@43     pointer_type     size: @22      algn: 64       ptd : @55     
                         addr: 7fe466cb2600 
@44     identifier_node  strg: void     lngt: 4        addr: 7fe466c9c720 
@45     identifier_node  strg: sum      lngt: 3        addr: 7fe466bc40c0 
@46     label_decl       type: @12      scpe: @1       srcp: test.c:8      
                         note: artificial              addr: 7fe466bc5100 
@47     label_decl       type: @12      scpe: @1       srcp: test.c:8      
                         note: artificial              addr: 7fe466bc5080 
@48     plus_expr        type: @7       op 0: @25      op 1: @13     
                         addr: 7fe46cc51300 
@49     integer_cst      type: @7       low : 1        addr: 7fe466caa510 
@50     le_expr          type: @7       op 0: @13      op 1: @56     
                         addr: 7fe46cc51280 
@51     goto_expr        type: @12      labl: @47      addr: 7fe46cc513c0 
@52     goto_expr        type: @12      labl: @53      addr: 7fe46cc51480 
@53     label_decl       type: @12      scpe: @1       srcp: test.c:8      
                         note: artificial              addr: 7fe466bc5180 
@54     modify_expr      type: @7       op 0: @57      op 1: @25     
                         addr: 7fe46cc51500 
@55     integer_type     name: @58      size: @6       algn: 8       
                         prec: 8        sign: signed   min : @59     
                         max : @60      addr: 7fe466c9d300 
@56     integer_cst      type: @7       low : 9        addr: 7fe466bc3450 
@57     result_decl      type: @7       scpe: @1       srcp: test.c:2      
                         note: artificial              size: @11     
                         algn: 32       addr: 7fe466bc5000 
@58     type_decl        name: @61      type: @55      srcp: <built-in>:0      
                         addr: 7fe466c9dcc0 
@59     integer_cst      type: @55      high: -1       low : -128    
                         addr: 7fe466c8d750 
@60     integer_cst      type: @55      low : 127      addr: 7fe466c8d8a0 
@61     identifier_node  strg: char     lngt: 4        addr: 7fe466c9bd20 

 ```
 
###4.4.3
```bash
(gdb) bt
#0  dump_node (t=0x7ffff1b2b000, flags=131064, stream=0xf89ba0) at ../.././gcc/tree-dump.c:740
#1  0x000000000056176d in gimplify_function_tree (fndecl=0x7ffff1b2b000) at ../.././gcc/gimplify.c:7465
#2  0x000000000045d738 in c_genericize (fndecl=0x7ffff1b2b000) at ../.././gcc/c-gimplify.c:107
#3  0x000000000040ed70 in finish_function () at ../.././gcc/c-decl.c:6823
#4  0x0000000000459d12 in c_parser_declaration_or_fndef (parser=0x7ffff7b5a140, fndef_ok=<value optimized out>, empty_ok=<value optimized out>, nested=0 '\000',
    start_attr_ok=<value optimized out>) at ../.././gcc/c-parser.c:1319
#5  0x000000000045c698 in c_parser_translation_unit () at ../.././gcc/c-parser.c:979
#6  c_parse_file () at ../.././gcc/c-parser.c:8314
#7  0x0000000000445375 in c_common_parse_file (set_yydebug=<value optimized out>) at ../.././gcc/c-opts.c:1252
#8  0x000000000064e254 in compile_file (argc=<value optimized out>, argv=<value optimized out>) at ../.././gcc/toplev.c:970
#9  do_compile (argc=<value optimized out>, argv=<value optimized out>) at ../.././gcc/toplev.c:2197
#10 toplev_main (argc=<value optimized out>, argv=<value optimized out>) at ../.././gcc/toplev.c:2229
#11 0x000000318ae1ecdd in __libc_start_main () from /lib64/libc.so.6
#12 0x00000000004043d9 in _start ()
```

###4.4.4
为了对上述的AST信息进行有效分析，尤其是各个AST节点之间的相互关系，可以使用http://www.graphviz.org提供的图形可视化工具Graphviz（Graph Visualization Software）对上述的AST信息进行图示，从而直观地进行AST分析。在进行图示前，需要对上述的AST信息进行处理，分析节点之间的关系，并转换成绘图脚本，最后调用graphviz提供的绘图工具绘制出这些节点之间的关系，例如本书中所有的AST节点图以及函数调用关系图等均是采用graphviz中的dot工具绘制。下面给出使用shell工具对AST信息进行提取，并进行图形绘制的shell脚本。其主要包括以下几个步骤：
####（1）pre.awk：使用awk脚本对AST文件信息进行预处理。
```bash
[GCC@localhost ast-node]$ cat pre.awk
        #! /usr/bin/gawk -f
            /^[^; ]/{
                gsub(/^@/, "～@", $0);
                gsub(/( *):( *)/, ":", $0);
                print;
            }
```
####（2）treeviz.awk：使用awk脚本将预处理后的AST信息转换成图形脚本。
```bash
  [GCC@localhost ast-node]$ cat treeviz.awk
        #! /usr/bin/gawk -f
        #http://alohakun.blog7.fc2.com/? mode=m&no=355
        BEGIN {RS = "～@"; printf "digraph G {\n node [shape = record]; \n"; }

        /^[0-9]/{
            s = sprintf("%s [label = \"{%s: %s | {", $1, $1, $2);
            for(i = 3; i < NF; i++)
                s = s sprintf("%s | ", $i);
            s = s sprintf("%s}}\"]; \n", $i);
            $0 = s;
            while (/([0-9a-zA-Z]+):@([0-9]+)/){
                format = sprintf("<\\1>\\1 \\3\n %s:\\1 -> \\2; ", $1);
                $0 = gensub(/([0-9a-zA-Z]+):@([0-9]+)(.*)$/, format, "g");
            };
            printf " %s\n", $0;
        }
        END {print "}"}
```
####（3）ast_to_dot.sh：调用上述两个awk处理脚本，并最终调用dot等绘图工具生成AST图形。
```bash
  [GCC@localhost ast-node]$ cat ast_to_dot.sh
    #/bin/bash
    # $1 为AST文件名称
    # $2 可以是字符串“all”表示图示AST中的所有节点
    # $2, $3, $4, …也可以是一系列的AST节点编号，则该脚本只图示指定编号的AST节点
    # 例如：
    # ./ast_to_dot.sh AST_file all 表示图示所有节点及其相关关系
    # ./ast_to_dot.sh AST_file 1 4 5 8 表示图示AST文件中编号为1、4、5、8等几个节点的信息及其关系

    # 获取AST文件名称
    f=$1

    # 对AST文件中一些特殊字段进行处理，将不必要的空格去掉
    sed -i "s/op\ 1/op1/g" $f
    sed -i "s/op\ 2/op2/g" $f
    sed -i "s/op\ 0/op0/g" $f

    #  对AST文件进行预处理，为了清晰起见，可以将一些“次要的”信息删除，减少图形中的信息，用户可以
根据需要修改
    ./pre.awk  $f  |  sed  's/srcp:[a-z_.:0-9<>-]*//  g'  |  sed  's/note:[a-z]*//  g'  |
sed 's/link:[a-z]*// g' |   sed 's/used:[0-9]*// g' | sed 's/algn:[0-9]*// g' |sed
's/prec:[0-9]*// g' |   sed 's/lngt:[0-9]*// g' | sed 's/sign:[a-z]*// g' > tmp1

    # 对简化后的AST文件进行转换，生成图形脚本文件$f.dot
    ./treeviz.awk tmp1 > $f.dot

    # 创建临时文件
    rm -f tmp; touch tmp

    #  如果$2表示全部转换，则直接使用上述转换后的dot脚本，否则，从上述生成的dot脚本中筛选相应的
节点，加入到tmp文件中
    if [ $2 ! = "all" ]
    then
       echo "digraph G {" >> tmp
       echo " node [shape = record]; " >> tmp
# 筛选给定的节点
       for n in $*
       do
            grep " $n " $f.dot >> tmp
            grep " $n:" $f.dot >> tmp_header
       done

       rm -rf tmp_header_tail
       for n in $*
       do
            grep " $n; " tmp_header >> tmp_header_tail
       done
    # 去除冗余的节点信息
       sort tmp_header_tail | uniq   >> tmp
       echo " }" >> tmp
    # 否则图示所有节点
    else
       cat $f.dot > tmp
    fi

    #调用graphviz中的dot工具绘图，节点字体大小为10point，输出文件格式为svg矢量图形格式，输
出文件名称为$f.svg
    dot -Nfontsize=10 -Tsvg tmp -o $f.svg
```


ast_to_dot.sh脚本有两种典型的执行方式：
（1）对AST文件中的所有内容进行处理并绘图，生成的图形文件名称为AST_FILE.svg。

        [GCC@localhost test]$ ./ast_to_dot AST_FILE all
（2）对AST文件中的编号为@node_num1, @node_num2, …等节点的内容进行处理并绘图，生成的图形文件名称为$AST_FILE.svg。

        [GCC@localhost test]$ ./ast_to_dot AST_FILE node_num1, node_num2, …
在某些情况下，读者只关注某个节点及其相关节点之间的关系，而忽略其他节点的信息，此时可以使用如下的脚本，用来图示某个节点及其相关节点（一般只打印到其两层子节点），该脚本名称为print_node.sh，内容如下：

```bash
      [GCC@localhost ast-node]$ cat print_node.sh
        #/bin/bash
        # $1 AST文件名称
        # $2 节点编号
        # $3 打印方向，取值为LR|RL|BT，分别表示按从left-to-right, right-to-left, bottom-to-top的
    方向画图，省略则表示从top-to-bottom
        # 例如：./print_node.sh AST-FILE 5 LR 表示图示@5号节点及其相关联的节点，图示的方向为从左到右
        # 获取AST文件名称
        f=$1
        # 获取给定的节点编号
        node=$2
        # 获取绘图方向
        rank=$3

        #对AST文件中一些特殊字段进行处理，将不必要的空格去掉
        sed -i "s/op\ 1/op1/g" $f
        sed -i "s/op\ 2/op2/g" $f
        sed -i "s/op\ 0/op0/g" $f

        #对AST文件进行预处理，为了清晰起见，将一些“次要的”信息删除，减少图形中的信息
        ./pre.awk $f | sed 's/srcp:[a-z_.:0-9<>-]*// g' | sed 's/note:[a-z]*// g' > tmp1

        #将预处理后的文件进行dot脚本的转换
        ./treeviz.awk tmp1 > $f.dot

        rm -f tmp; touch tmp

        # 生成dot脚本的首部
              echo "digraph G {" >> tmp
              echo " node [shape = record]; " >> tmp

              rm -rf tmp_header
              # 筛选与node节点有关的关联关系
              grep " $node " $f.dot >> tmp
              grep " $node:" $f.dot >> tmp_header

              # 查找以node为起始节点的关联关系
              tail=`grep " $node:" $f.dot | awk '{print $3}' | sed 's/; // g'`

              # 将node关联的子节点信息加入到tmp文件中
              for n in $tail
              do
                grep " $n " $f.dot >> tmp
                grep " $n:" $f.dot >> tmp_header
              done

              [ -f tmp_header ] && sort tmp_header | uniq   >> tmp

              # 生成dot脚本的结束部分
              echo " }" >> tmp

              # 根据方向参数，调用graphviz中的dot工具绘图
              if [ -z $rank ]
              then
                dot -Nfontsize=10 -Tsvg tmp -o ${f}_${node}.svg
              else
                dot -Nfontsize=10 -Grankdir=${rank} -Tsvg tmp -o ${f}_${node}.svg
              fi
```
例如，如果执行下述命令：

          [GCC@localhost ast-node]$ ./print_node AST-main 1 LR
          
 就可以根据例4-18中的AST信息，将@1号节点及其关联的节点输出为图4-22所示的内容，其中的打印方向为从左向右（LR, Left-to-Right）。从中可以清晰地看出函数声明节点（@1号节点）与标识符节点（@2号节点）、函数类型节点（@3号节点）、参数声明节点（@4号节点）以及BIND_EXPR表达式节点（@5号节点）之间的关系。
 ![](res/4-22.png)
 
 通过使用上述的脚本，用户可以很方便地显示AST中的部分节点及其相互关系，或者某个节点所关联的其他节点，有了AST的图示，对于理解AST非常有帮助。
例4-19 图示AST中的部分信息
有了上述AST图示的脚本，就可以对例4-18中的AST进行图形化显示。例如，当读者对函数声明感兴趣时，可以使用：

          [GCC@localhost ast-node]$ ./print_node AST-main 1 LR
打印出该节点所关联的节点，如图4-22所示。
当读者对main函数中的BIND_EXPR节点感兴趣时，可以使用：

            [GCC@localhost ast-node]$ ./print node AST-main 5 LR
打印该信息，其中的5表示BIND_EXPR节点的节点编号，结果如图4-23所示。
在使用图示工具的时候，需要对需要图示的内容进行筛选，否则可能导致图形过大、关系过于复杂而大大影响节点关系的分析。例如，通常读者可以直接使用．/ast_to_dot.sh AST-main all将所有的节点及其关系绘制出来，但是当节点很多时，图中的节点和连接关系就非常复杂，反倒失去了图示的优势，所有，当AST中节点较少时，可以使用．/ast_to_dot.sh all打印完整的AST图，更多的情况是打印图中读者比较感兴趣的节点，此时可以通过给定．/ast_to_dot.sh传递合适的节点编号，也可以通过．/print_node.sh对指定的节点进行图示。

 